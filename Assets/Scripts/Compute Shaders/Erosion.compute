// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define MAX_UINT 4294967295

// Buffers
RWStructuredBuffer<float3> _VertexBuffer;
StructuredBuffer<int> _RainDropBuffer;
StructuredBuffer<uint> _Dimension; // {mapWidth, mapHeight}

// Variables
uint numVertices;
float inertia;
float maxSediment;
float depositionRate;
float evaporationRate;
float softness;


// v is the vertex number that we want to get the normal of
float3 GetVertexNormal(uint v)
{
    uint width = _Dimension[0] + 1;
    uint x = v % width;
    uint y = (v - x) / width;
    
    float3 normalSum = float3(0.0f, 0.0f, 0.0f);
    float3 AB, AC, faceNormal;
    
    
    // Top Left triangle
    if (x > 0 && y > 0)
    {
        AB = _VertexBuffer[v - 1] - _VertexBuffer[v];
        AC = _VertexBuffer[v - width] - _VertexBuffer[v];
        faceNormal = normalize(cross(AB, AC));
        normalSum += faceNormal;
    }
    
    // Top Middle and Top Right triangles
    if (x < _Dimension[0] && y > 0)
    {
        // Top Middle
        AB = _VertexBuffer[v - width] - _VertexBuffer[v];
        AC = _VertexBuffer[v - width + 1] - _VertexBuffer[v];
        faceNormal = normalize(cross(AB, AC));
        normalSum += faceNormal;
        
        // Top Right
        AB = _VertexBuffer[v + 1] - _VertexBuffer[v];
        faceNormal = normalize(cross(AC, AB));
        normalSum += faceNormal;
    }
    
    // Bottom Right triangle
    if (x < _Dimension[0] && y < _Dimension[1])
    {
        AB = _VertexBuffer[v + 1] - _VertexBuffer[v];
        AC = _VertexBuffer[v + width + 1] - _VertexBuffer[v];
        faceNormal = normalize(cross(AB, AC));
        normalSum += faceNormal;
    }

    // Bottom Middle and Bottom Left triangles
    if (x > 0 && y < _Dimension[1])
    {
        // Bottom Middle
        AB = _VertexBuffer[v + width] - _VertexBuffer[v];
        AC = _VertexBuffer[v + width - 1] - _VertexBuffer[v];
        faceNormal = normalize(cross(AB, AC));
        normalSum += faceNormal;
        
        // Bottom Left
        AB = _VertexBuffer[v - 1] - _VertexBuffer[v];
        faceNormal = normalize(cross(AC, AB));
        normalSum += faceNormal;
    }

    
    // hlsl internally safeguards against division by 0
    return normalize(normalSum);
}


// Gets closest vertex to world position
uint GetClosestVertex(float2 pos)
{
    // Rounding takes us from face position to nearest vertex row/column
    int x = round(pos.x * _Dimension[0]);
    int y = round(pos.y * _Dimension[1]);

    // We're off the map
    if (x < 0 || (uint)x > _Dimension[0] || y < 0 || (uint)y > _Dimension[1])
    {
        return MAX_UINT;
    }

    // Correct vertex
    return x * (_Dimension[1] + 1) + y;
}


// Simulate a raindrop picking up and depositing sediment
void SimulateDrop(uint v) 
{
    float2 position = float2(_VertexBuffer[v].x, _VertexBuffer[v].z);
    float sediment = 0;
    float volume = 1;
    float2 velocity = float2(0.0f, 0.0f);
    
    
    while (volume > 0)
    {
        // Get vertex
        uint i = GetClosestVertex(position);
        
        // Early Out
        if (i == (uint)MAX_UINT) break;

        // Calculate normal
        float3 vertexNormal = GetVertexNormal(i);
        
        // Max Sediment a particle can hold
        float maxSed = maxSediment * length(velocity) * volume;
        float3 vert = _VertexBuffer[i];
        
        if (sediment > maxSed)
        {
            // Deposit sediment to terrain
            float depositAmount = depositionRate * (sediment - maxSed);
            sediment -= depositAmount;
            vert[1] += depositAmount;
        }
        else
        {
            // Take sediment from the terrain
            float erosionAmount = softness * (maxSed - sediment);
            sediment += erosionAmount;
            vert[1] -= erosionAmount;
        }
        _VertexBuffer[i] = vert;
        
        // Evaporation
        volume -= evaporationRate;

        // Update velocity based on normals
        float2 dir = float2(-vertexNormal.x, -vertexNormal.z);
        velocity = velocity * inertia - dir * (1-inertia);
        
        // Update Position
        position += velocity;
    }
}


[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numVertices) return; // Don't need to iterate on
    
    SimulateDrop(_RainDropBuffer[id.x]);
}
