// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#define MAX_UINT 4294967295

// Buffers
RWStructuredBuffer<float3> _VertexBuffer;
StructuredBuffer<int> _RainDropBuffer;
StructuredBuffer<uint> _Dimension; // {mapWidth, mapHeight}

// Variables
uint numVertices;
float inertia;
float maxSediment;
float depositionRate;
float evaporationRate;
float softness;

float3 GetGradientAndHeight(float2 pos)
{
    // Get row/column of top left index of (square) face
    int row = (int)pos.x;
    int col = (int)pos.y;
    int index = col * (_Dimension[0] + 1) + row;

    // Get height of all vertices of square
    float nw = _VertexBuffer[index].y;
    float ne = _VertexBuffer[index + 1].y;
    float sw = _VertexBuffer[index + (_Dimension[0] + 1)];
    float se = _VertexBuffer[index + (_Dimension[0] + 1) + 1];
    
    // Get coordinates of drop in (square) face.
    // Top left is (0,0)
    float u = pos.x - row;
    float v = pos.y - col;

    // Bilinear Interpolation of heights to get gradient direction and height
    float angleX = (ne - nw) * (1-v) + (se - sw) * v;
    float angleY = (sw - nw) * (1-u) + (se - ne) * u;
    float height = nw * (1-u) * (1-v) + ne * u * (1-v) + sw * (1-u) * v + se * u * v;

    return float3(angleX, angleY, height);
}


// Simulate a raindrop picking up and depositing sediment
void SimulateDrop(uint v) 
{
    // Local drop variables
    // Position is on a grid between mapWidth + 1 and mapHeight + 1
    float2 position = float2(float(v) % (_Dimension[0] + 1), float(v) / (_Dimension[0] + 1));
    float2 velocity = float2(0.0f, 0.0f);
    float2 dir = float2(0.0f, 0.0f);
    float volume = 1;
    float sediment = 0;

    // Max Steps to ensure drop doesn't move endlessly
    // TODO: Perhaps find a way so that heightAndGradient aren't calculated twice
    while (volume > 0)
    {
        float3 g = GetGradientAndHeight(position);
        float2 gradient = float2(g.x, g.y);
        float oldHeight = g.z;

        // Update flow direction based on gradient
        // Inertia determines how much gradient is taken into account
        dir = dir * inertia - gradient * (1 - inertia);
        normalize(dir); // Drop moves fixed distance, so erosion is evenly distributed

        // Find next position
        float2 newPos = position + dir;
        float newHeight = GetGradientAndHeight(newPos).z;

        // is drop ascending?
        if (newHeight > oldHeight)
        {
            // Either completely fill pit at oldPos or deposit all sediment there
            float fill = min(sediment, oldHeight - newHeight);
            // TODO: doStuff
        }
        else // downHill
        {
            // Speed and size of the drop determine how much sediment it can hold
            float minSlope = .03f;
            float dropCapacity = max(oldHeight - newHeight, minSlope) * velocity * volume * maxSediment;

            // can the drop hold more sediment
            if (sediment > dropCapacity)
            {
                float depAmount = (sediment - dropCapacity) * depositionRate;
                // subtract and put at old position
                
            }
            else
            {
                // Can't take more sediment than height difference
                float depAmount = min((dropCapacity - sediment) * softness, oldHeight - newHeight);
            }
        }

        // Velocity is adjusted depending upon the slope and gravity
        float gravity = 9.81f;
        velocity = sqrt(pow(velocity,2) + (newHeight - oldHeight) * gravity);

        // Update Position
        position = newPos;
        volume = volume * (1-evaporationRate);




        
    }
}


[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numVertices) return; // Don't need to iterate on
    
    SimulateDrop(_RainDropBuffer[id.x]);
}
