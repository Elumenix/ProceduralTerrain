// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct VertexData
{
    float3 position;
    float2 uv;
    float3 normal;
};

// Buffers
RWStructuredBuffer<float> _HeightMap;
RWStructuredBuffer<VertexData> _VertexDataBuffer;

// Variables
uint numVertices;
uint2 dimension; // {mapWidth, mapHeight} Based on number of faces, not number of vertices
float heightMultiplier;
float2 scale; // essentially a float 2


[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numVertices) return; // Don't need to iterate on

    // find x/z position on the map
    int x = id.x % (dimension[0] + 1);
    int z = id.x / (dimension[0] + 1);

    // Update relevant data for each vertex
    float newHeight = _HeightMap[id.x] * heightMultiplier; // Add curve here if wanted
    _VertexDataBuffer[id.x].position = float3(x * scale.x, newHeight, z * scale.y);
    _VertexDataBuffer[id.x].uv = float2(x * scale.x, z * scale.y); // World Space Uv's
    _HeightMap[id.x] = newHeight;


    // Previous/Past options to help with understanding
    //_VertexBuffer[id.x] = float3(x * _Scale[0], /*heightCurve.Evaluate(_HeightMap[id.x])*/ newHeight, z * _Scale[1]);
    //_UVBuffer[id.x] = float2(x * _Scale[0], z * _Scale[1]); // World space Uv's
    //_UVBuffer[id.x] = float2(x / (float)_Dimension[0], z / (float)_Dimension[1]); //normalized Uv's
    //colorMap[i] = Color.Lerp(Color.black, Color.white, heightMap[i]);
}
